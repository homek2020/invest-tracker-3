# invest-tracker-3
# Требования к платформе мониторинга состояния инвестиционных счетов

## 1. Общие положения

Веб-приложение предназначено для мониторинга инвестиционных счетов пользователя. Оно позволяет:

* Просматривать и отслеживать остатки по всем активным счетам
* Видеть месячную динамику и доходность по каждому счету
* Управлять списком инвестиционных счетов
* Вести журнал остатков с помесячным закрытием и автоматизацией переноса входящих остатков
* Вводить коррекционные операции (нетто приток/отток) за месяц (например, пополнение или снятие средств)
* Вести остатки в разных валютах с последующей конвертацией по курсу ЦБ РФ

---

## 2. Пользовательские роли

* **Обычный пользователь**: имеет полный доступ к своим счетам и полную функциональность

---

## 3. Счета

### 3.1. Свойства счета

* Уникальное наименование (заполняется пользователем)
* Провайдер счёта: выбор из фиксированного списка: Finam, TradeRepublic, BYBIT, BCS, IBKR
* Логотип провайдера: отображается (можно подгружать/привязывать автоматически по провайдеру)
* Валюта счета: RUB, USD, EUR, (опционально расширяемый перечень)
* Статус (active, archived) определяет, отображается ли счет в операциях
* Архивные счета скрыты в основном интерфейсе, но не удаляются

### 3.2. Управление счетами

* Создание, редактирование, архивирование/добавление/удаление счета (удаление возможно только если нет истории по счету)

---

## 4. Остатки и месячная динамика

### 4.1. Ведение остатков

* Для каждого счета пользователь вручную вносит значение текущего остатка в любой момент календарного месяца.
* Остатки могут фиксироваться по инициативе пользователя в любое время — например, по итогам дня, недели или другого события; нет требования фиксировать остатки только при закрытии месяца.
* Остатки подтверждаются датой и временем внесения; данные сохраняются с указанием периода (год и месяц видны в заголовке экрана).
* Главный экран отображает текущий месяц и год, позволяет быстро просматривать и вводить/редактировать остатки по всем активным счетам.
* Для каждого счета в рамках месяца сохраняется только одно актуальное значение остатка — последнее внесённое пользователем для данного счета в текущем месяце.
* При вводе нового значения остатка предыдущее значение для этого месяца заменяется.
* Для корректных вычислений реализовать формирование «закрытия месяца»:

  * После закрытия месяца данные о остатках и нетто-притоках в данном периоде блокируются для редактирования
  * Автоматически создаётся новый месяц, входящие остатки нового месяца = исходящим остаткам закрытого месяца
  * В закрытых месяцах редактирование данных запрещено
* Для счета хранится только итоговое, актуальное значение остатка на конец каждого месяца (историю изменений значения в течение месяца не хранить).
* Для полей баланса и нетто-притока на уровне UI и бэкенда допускается ввод только чисел с точностью до двух знаков после запятой (например, 123456.78).
* Остатки и нетто-притоки не могут быть отрицательными — при попытке ввода/сохранения отрицательных значений должна возвращаться ошибка/валидация как на фронте, так и на сервере.

### 4.2. Нетто-притоки/оттоки

* В разрезе счетов пользователь указывает отдельной строкой за каждый месяц сумму нетто-притока: разницу между вводом/выводом средств (например, пополнение или снятие через кассу/биржу).
* Нетто-приток/отток вычисляется вручную, отдельного учета транзакций нет (в рамках текущей версии).
* На уровне UI и валидации — допускается только два знака после запятой, отрицательные значения запрещены.

*(Примечание: этот блок про отрицательность может быть синхронизирован/изменён в соответствии с финальной моделью, если `net_flow` решено хранить со знаком.)*

---

## 5. Курсы валют

* Для всех используемых валют автоматически подгружаются курсы с сайта cbr.ru (ЦБ РФ) — ежедневно или при необходимости (например, при изменении отчетного месяца).
* Значения остатков в иностранных валютах конвертируются автоматически по соответствующему курсу на дату закрытия месяца для отображения совокупных итогов в рублях.

---

## 6. Расчёт доходности

* Доходность за каждый месяц рассчитывается как разница между исходящим остатком текущего месяца и входящим (с учетом нетто-притока/оттока за месяц).

Формула абсолютной доходности:

```text
Доходность = (Исходящий остаток - Входящий остаток - Нетто-приток)
```

Процентная доходность (относительная):

```text
Процентная доходность = Доходность / (Входящий остаток + Нетто-приток) * 100%
```

* Отображается график доходности с разбивкой по месяцам, суммарная доходность за выделенный период.

---

## 7. Интерфейс

### 7.1. Общая структура

Приложение следует общепринятой современной компоновке веб-интерфейса (“dashboard layout”):

* **Боковое меню (sidebar, слева)** с основными разделами:

  * **Дашборд** (Dashboard)
  * **Балансы** (Balances) — детализированные остатки по счетам и ввод/редактирование значений
  * **Счета** (Accounts) — управление списком счетов, добавление/архивация/редактирование
  * **Настройки** (Settings)

* **Основная область (content area)** — отображение соответствующего экрана в зависимости от выбранного пункта меню.

### 7.2. Дашборд

В верхней части дашборда отображается:

* Текущая дата (в формате ДД.ММ.ГГГГ)
* Суммарный итоговый баланс по всем счетам, конвертированный в выбранную пользователем валюту (RUB/USD/EUR) по актуальному курсу ЦБ РФ.
* Доходность (абсолютная и процентная) за текущий месяц по всем счетам, в выбранной валюте.

**График динамики активов:**

* Линейный или столбчатый график изменения суммарного баланса за последние 6–12 месяцев (данные берутся из закрытых месяцев, либо из текущего актуального состояния).
* Варианты отображения: абсолютные значения и доходность (проценты).
* Возможность выбрать период (по умолчанию — последние 12 месяцев).

Все основные элементы дашборда должны быть визуально отделены:

* Итоговые цифры (баланс, доходность) оформляются как виджеты/карточки.
* Графическая аналитика — отдельный блок.

### 7.3. Боковое меню

Содержит иконки и/или текстовые подписи для следующих разделов:

* Дашборд
* Балансы (остатки)
* Счета
* Настройки

При выборе пункта меню основная область обновляется согласно выбранному разделу.

### 7.4. Общие замечания по UX/UI

* Интерфейс должен быть адаптивным (Responsive), корректно отображаться на десктопах и планшетах.
* Для числовых данных (остатки, доходности) использовать форматирование с учетом выбранной пользователем валюты, единых разделителей.
* Цветовое оформление: современный светлый или тёмный дизайн, поддержка тем оформления (опционально).
* Все основные операции (ввод остатков, закрытие месяца, добавление/редактирование счетов) доступны максимум в 1–2 клика из соответствующих разделов.
* Для перехода между месяцами — выпадающий список или стрелки “влево/вправо” в верхней части страницы.

### 7.5. Остальные экраны

* **Балансы**: таблица по счетам для текущего выбранного месяца; быстрый ввод/редактирование остатков, нетто-притока, просмотр текущих курсов валют.
* **Счета**: список всех счетов с указанием провайдера, названия, валюты, статуса (активный/архив); кнопки добавления и редактирования.
* **Настройки**: выбор валюты отображения, опции по способу отображения данных, экспорт/импорт (опционально).

---

## 8. Бизнес-правила

* Добавление/изменение/удаление счетов разрешено только в “открытом” (текущем) месяце.
* После “закрытия месяца” данные по периодам могут просматриваться, но не редактироваться.
* Все пересчёты производятся автоматически при изменении исходящих данных (остатков, притоков, курсов валют).
* Курсы валют могут храниться в истории, привязанными к дате закрытия месяца.
* (Опционально) поддержка пользовательской настройки валют по умолчанию.

---

## 9. Сценарии использования

### 9.1. Создание нового счета

1. Пользователь выбирает “Добавить счет”, выбирает провайдера (из списка), вводит имя, указывает валюту.
2. Счет появляется в списке, остаток по счету пока не вводился.

### 9.2. Ввод остатков

1. В конце месяца или по инициативе пользователь вводит остатки на всех счетах на главном экране.
2. При необходимости указывает нетто-приток средств.

### 9.3. Закрытие месяца

1. Пользователь нажимает “Закрыть месяц”.
2. Остатки фиксируются, новый месяц становится “открытым”.
3. Входящие остатки нового месяца заполняются автоматически.

### 9.4. Просмотр истории

1. Пользователь переключается между месяцами для просмотра истории остатков, притоков, доходности.

---

## 10. Общая архитектура и UX/UI стандарты

### 10.1. Единая таблица стилей (Theme/Style System)

* Для всего интерфейса приложения используется единая таблица стилей (CSS/SCSS/ThemeProvider/etc.):

  * Все основные параметры дизайна (цвета, отступы, радиусы, шрифты, размеры, состояния элементов, стили кнопок и карточек) вынесены в отдельный централизованный файл или theme-объект.
  * Замена или донастройка дизайна (например, светлая/тёмная темы, настройка фирменных цветов провайдера, глобальные изменения шрифтов и т.д.) должна производиться централизованно и универсально для всех компонентов.
  * Все UI-компоненты (кнопки, поля ввода, таблицы, виджеты и т.д.) используют исключительно переменные и компоненты из общей таблицы стилей.
  * Для кастомизации используется механизм темизации (ThemeProvider, CSS custom properties или аналог).

* Кодовая база не содержит дублирующихся inline-стилей или хардкоженных цветовых/визуальных параметров.

### 10.2. Единая логика спиннеров и индикации ожидания

* Для всех действий с асинхронным ожиданием (отправка формы, получение данных, нажатие на кнопки сохранения/закрытия/обновления и т.д.) реализуется единый компонент спиннера (индикатора загрузки):

  * Использование единого визуального компонента-спиннера, соответствующего стилю приложения.
  * Спиннер появляется внутри кнопки или над соответствующим элементом управления (например, замещает надпись на кнопке “Сохранить” на вращающийся индикатор до завершения действия).
  * В приложении не используются дублирующие или несовместимые реализации спиннеров; вся индикация ожидания полностью стандартизирована.
  * Компоненты и страницы используют универсальный механизм управления состоянием ожидания (например, через централизованный state/store или custom hooks).

* Для ошибок и состояния асинхронных действий также используются единые уведомления/алерты, реализованные как часть общей дизайн-системы.

* **Важное требование:** В момент обработки действия (например, отправки формы после нажатия кнопки "Сохранить", "Закрыть месяц", добавления/редактирования счета и т.п.) поля ввода в соответствующей форме, а также все элементы управления, связанные с этим действием, должны становиться неактивными (disabled) до завершения операции.

  * Это особенно важно для экранов "Балансы" и "Счета": во время обработки запроса пользователь не может менять значения полей, чтобы предотвратить рассинхронизацию состояния UI и данных.

### 10.3. Требования к доступности (Accessibility, a11y)

* Использовать современные стандарты a11y для поддержки клавиатурной навигации, читателей экрана, достаточной контрастности и “aria”-меток.
* Интерфейс должен быть пригоден для работы пользователями с ограниченными возможностями.

### 10.4. Валидация числовых данных

* В интерфейсе и валидации API для всех денежных и цифровых полей (остатки, нетто-притоки, суммы доходности):

  * Поддерживаются числовые значения с точностью не более двух знаков после запятой.
  * Все значения балансов, доходностей, операций — неотрицательные. Валидация выполняется обязательно на клиенте и сервере.

---

## 11. Модель данных

В приложении используются следующие основные сущности и их атрибуты:

### 11.1. Пользователь (User)

* `id` (уникальный идентификатор)
* `email`
* `пароль` (хэш, если есть авторизация)
* `настройки` (json/object: выбранная валюта отображения, тема приложения и пр.)

### 11.2. Счет (Account)

* `id` (уникальный идентификатор)
* `user_id` (связь с пользователем)
* `name` (наименование счёта)
* `provider` (имя провайдера: Finam, TradeRepublic, BYBIT, BCS, IBKR)
* `provider_logo_url` (ссылка на иконку провайдера)
* `currency` (валюта счёта: RUB, USD, EUR и др.)
* `status` (статус: active, archived)
* `created_at` (дата создания)
* `updated_at` (дата последнего обновления)

### 11.3. Остаток по счету и нетто-приток (AccountBalance)

* `id` (уникальный идентификатор)
* `account_id` (связь со счетом)
* `period_year` (год периода, например, 2025)
* `period_month` (месяц периода, 1–12)
* `amount` (остаток, последнее актуальное значение на данный месяц)
* `net_flow` (нетто-приток/отток за месяц)
* `updated_at` (дата и время последнего изменения)
* `is_closed` (флаг — месяц закрыт/открыт, для запрета правок после закрытия месяца)

### 11.4. Валютный курс (CurrencyRate)

* `id` (уникальный идентификатор)
* `date` (дата курса, типично последняя дата месяца или текущая дата)
* `base_currency` (например, RUB)
* `target_currency` (например, USD, EUR)
* `rate` (курс ЦБ РФ)
* `source` (откуда взят курс, например cbr.ru)
* `fetched_at` (дата и время получения курса)

### 11.5. Параметры приложения и пользовательские настройки (AppSettings/UserSettings — опционально)

* `id` (уникальный идентификатор)
* `user_id`
* `display_currency` (валюта отображения UI по умолчанию)
* `theme` (тема интерфейса: светлая/тёмная)
* дополнительные ключи (например, формат дат, прочие опции).

**Связи сущностей (общие):**

* Пользователь может иметь много счетов.
* Каждый счет — много историй остатков (по месяцам).
* Курсы валют и настройки не привязаны к счетам напрямую, используются для пересчётов и интерфейса.

**Особенности:**

* Для каждого счета и месяца хранится только одно текущее актуальное значение остатка и нетто-притока.
* Данные о курсах валют могут храниться по дате закрытия месяца для валютной синхронизации отчетности.
* Архивирование счета осуществляется сменой статуса (`status`), а не отдельным флагом.

**Расчёты доходностей и конвертаций выполняются на лету**:

Для расчетов доходности и конвертации валют все нужные значения вычисляются на стороне бэкенда на основании актуальных и исторических значений остатка, нетто-притока и валютных курсов. Дополнительного хранения результатов расчетов не требуется.

---

## 12. Инициализация структуры БД и первый пользователь (API)

### 12.1. Специальный API-метод “инициализации” (setup/init)

* Предусмотреть отдельный endpoint (например, `POST /api/init`), который:

  * При вызове проверяет, что база данных пуста (или соответствующие таблицы не существуют).
  * Если таблицы отсутствуют — создает структуру всех необходимых таблиц согласно модели данных (см. раздел “Модель данных”), включая индексы и ограничения.
  * Если таблицы существуют — может возвращать ошибку (или игнорировать с оповещением, что инициализация уже была выполнена).
  * В случае успешного создания структуры создает **первого пользователя** с минимальными необходимыми атрибутами:

    * email, пароль (или без пароля/по email, если авторизация не предусмотрена).
    * Допускается передавать email и пароль администратора в теле запроса (или использовать дефолтные значения).
  * Возвращает результат: идентификатор созданного пользователя и статус операции.

* Доступ к методу инициализации должен быть ограничен (например, допускается только при пустой базе, либо по секретному initial-токену).

### 12.2. Минимальный сценарий использования

1. Новый инстанс приложения (пустая БД).
2. Вызов `POST /api/init` с payload:

   ```json
   {
     "email": "admin@yourdomain.ru",
     "password": "password"
   }
   ```
3. Сервер:

   * Поднимает нужные таблицы с необходимыми индексами и ограничениями.
   * Вносит первого пользователя (админа/владельца).
   * Возвращает json с результатом:

     ```json
     {
       "success": true,
       "user_id": "uuid/числовой id",
       "message": "Initial user created"
     }
     ```
4. Повторный вызов после успешной инициализации должен блокироваться с понятным сообщением.

**Важно:**

Документировать структуру ответа и ограничения доступа к init-методу. Реализация допускает как SQL, так и ORM-подход.

---

## 13. API-эндпоинты (REST/HTTP API)

Ниже приведены основные API, которые должны быть реализованы бэкендом.

### 13.1. Авторизация/Аутентификация

* **POST /api/auth/register**
  Регистрация пользователя.

  * Request: `{ "email": "user@domain.ru", "password": "pass" }`
  * Response: `{ "user_id": "...", "token": "..." }`

* **POST /api/auth/login**
  Вход пользователя.

  * Request: `{ "email": "user@domain.ru", "password": "pass" }`
  * Response: `{ "user_id": "...", "token": "..." }`

* **GET /api/auth/profile**
  Получить детали текущего пользователя по access-токену.

### 13.2. Счета (Accounts)

* **GET /api/accounts**
  Получить список счетов пользователя.

* **POST /api/accounts**
  Создать новый счет.

  Request:

  ```json
  {
    "name": "My Finam",
    "provider": "Finam",
    "currency": "RUB"
  }
  ```

* **GET /api/accounts/{account_id}**
  Получить детали счета.

* **PUT /api/accounts/{account_id}**
  Изменить параметры счета (имя, провайдер, валюта, статус).

* **DELETE /api/accounts/{account_id}**
  Удалить счет (если нет данных по остаткам).

### 13.3. Балансы и притоки (Balances & Net Flows)

* **GET /api/balances?period_year=YYYY&period_month=MM**
  Получить актуальные остатки и нетто-притоки по всем счетам пользователя за указанный месяц.

* **POST /api/balances/batch**
  Сохранить/обновить актуальные остатки и нетто-притоки по коллекции счетов пользователя за указанный месяц одной операцией (массовое обновление).

  Request:

  ```json
  {
    "period_year": 2025,
    "period_month": 11,
    "balances": [
      {
        "account_id": "uuid1",
        "amount": 123456.78,
        "net_flow": 20000
      },
      {
        "account_id": "uuid2",
        "amount": 30000,
        "net_flow": 0
      }
    ]
  }
  ```

* В массиве `balances` указываются только те счета, по которым на текущий момент есть данные для обновления (необязательно все счета пользователя).

* Данные обновляются по каждому переданному в массиве счету.

* Запрос может содержать как полную коллекцию счетов, так и часть счетов пользователя за данный период; это не атомарная операция для всех счетов.

* После сохранения данных возвращается результат обновления по каждому счету или общий успех.

* **GET /api/balances/{account_id}?period_year=YYYY&period_month=MM**
  Получить остаток и нетто-приток по конкретному счету и месяцу (для просмотра/аналитики).

### 13.4. Операции с месяцами

* **POST /api/months/close**
  Закрыть текущий месяц для пользователя (фиксирует все остатки/нетто-притоки, запрещает редактирование, создает следующий месяц с входящими остатками).

* **GET /api/months/history**
  Получить список закрытых месяцев и их состояние.

### 13.5. Валюты и курсы

* **GET /api/currency-rates?date=YYYY-MM-DD**
  Получить курсы валют (или за месяц, или за конкретную дату).

### 13.6. Дашборд/Агрегации (Dashboard)

* **GET /api/dashboard?period_year=YYYY&period_month=MM**
  Получить агрегированные сводные данные для отображения на дашборде (сумма всех балансов в выбранной валюте, доходность общая и по счетам, динамика за период).

### 13.7. Настройки пользователя

* **GET /api/user/settings**
  Получить настройки пользователя (валюта интерфейса, тема и др.).

* **PUT /api/user/settings**
  Изменить пользовательские настройки.

### 13.8. Инициализационный endpoint

* **POST /api/init**
  (см. раздел выше — создание структуры БД и первого пользователя).

### 13.9. Стандартные для любой сущности

* Для всех сущностей: поддержка пагинации, фильтрации по датам (где уместно) и возврат в виде стандартизированных json-структур с кодами ошибок и успешными статусами.

**Замечания:**

* Для всех write-операций требуется авторизация (access token).
* Ошибки и валидность входных данных проверяются на сервере, возвращается описание ошибки.
* Возвращаемые структуры включают все поля, необходимые для клиентской логики и UI без лишних данных.

---

## 14. Архитектурные требования

### 14.1. Трёхслойная архитектура (Three-tier architecture)

Приложение должно быть реализовано на основе классической трёхслойной архитектуры:

1. **Слой представления (View/UI Layer):**

   * Отвечает только за взаимодействие с пользователем, отображение данных и прием вводимых значений.
   * Не содержит бизнес-логики и прямого обращения к слою доступа к данным.

2. **Слой бизнес-логики (Business Logic Layer / Service Layer):**

   * Содержит основную предметную (бизнес-) логику приложения: обработку данных, вычисления, проверки, автоматизацию “закрытия месяца”, агрегации и расчет доходностей, применимость операций и т.д.
   * Работает только с моделью предметной области, принимает данные от слоя представления и возвращает готовые для UI структуры.
   * Не содержит прямых зависимостей от реализации физической модели хранения данных и вида UI.

3. **Слой доступа к данным (Data Access Layer / Repository Layer):**

   * Отвечает исключительно за работу с физическим хранилищем данных (БД, API, файловая система и др.).
   * Предоставляет абстракцию (интерфейсы, репозитории, провайдеры) для чтения, сохранения, обновления и удаления данных.
   * Не связан с UI и не содержит бизнес-логики.
   * Все бизнес-правила реализуются исключительно на Service-слое.

Паттерн: **UI → Service → Repository (Data)**.

### 14.2. Независимость слоя работы с физической моделью

* Слой доступа к данным реализуется так, чтобы его было возможно относительно легко заменить (например, с SQL на NoSQL, или на внешний API), не затрагивая ни слой бизнес-логики, ни слой представления.
* Используются абстракции (интерфейсы репозиториев, DAO, data provider и пр.) для взаимодействия бизнес-логики с хранилищем.
* В бизнес-логике и интерфейсе допускается только работа с контрактами (интерфейсами, DTO) слоя данных, а не с конкретной реализацией БД/ORM.
* Для тестирования (юнит-тесты) возможно подменить слой данных на in-memory storage или mock-репозитории без изменения бизнес-логики приложения.
* Допускается как классическая реализация трёхслойки, так и использование DDD-подходов (Entity/Repository/Service).

**Цель:**

Обеспечить хорошую поддерживаемость, возможность расширять или менять физическую модель хранения данных или UI без рефакторинга бизнес-логики, а также эффективное тестирование бизнес-логики независимо от БД и внешних зависимостей.

---

## 15. Технические требования к стеку технологий

### 15.1. Фронтенд

* **React + TypeScript**

  * Использовать для web-интерфейса.
  * Применять современные UI-фреймворки (MUI, AntDesign, Chakra и т.п.).
  * Использовать CSS-in-JS (styled-components или emotion) для стилизации компонентов.
  * Архитектурное разделение по трёхслойной модели (UI — бизнес-логика — API).
  * Все бизнесовые хуки и модели реализовывать максимально переиспользуемо: предусматривать повторное использование в мобильном приложении (React Native).

* **React Native + TypeScript** *(опционально)*

  * Общие ядро-модули (бизнес-логика, функции работы с API и моделями) должны быть написаны так, чтобы повторно использоваться из веба.
  * Использовать те же DTO и бизнес-модели, что и на вебе.

* **PWA-режим**

  * Предусмотреть возможность развёртывания фронтенда как Progressive Web App.

### 15.2. Бэкенд

* **Node.js (TypeScript) + Express, Koa или NestJS**

  * REST API в стиле, описанном в разделе API.
  * Вся бизнес-логика и слой работы с базой вынесены в отдельные сервисы и репозитории, без прямых завязок на технологию хранения.
  * Документация API — OpenAPI/Swagger.

* **Альтернативы:** Python (FastAPI), Go, .NET, Java Spring — допускаются при наличии опыта команды.

### 15.3. База данных

* **MongoDB**:

  * Основная база данных для хранения всех данных (пользователи, счета, балансы, курсы валют и т.д.).
  * Использовать коллекции, отражающие модель данных (`accounts`, `balances`, `users`, `currency_rates` и др.).
  * Интеграция через современный драйвер (mongoose/mongo client для Node.js и т.п.).
  * Предусмотреть создание необходимых индексов для повышения производительности выборок по пользователю, месяцу, счету.
  * Описывать модели через системы валидации/ORM-схемы (например, Mongoose schemas).

### 15.4. Общие требования по переносимости/портируемости

* Все модели данных (DTO), валидаторы, сервисы должны быть реализованы так, чтобы обеспечить максимальное переиспользование кода между web и мобильной версией (React + React Native).
* Вся бизнес-логика оформляется в виде сервисов/модулей, не зависящих от окружения UI.
* Слой работы с MongoDB реализуется через абстракции (repository, data provider) — должна быть возможность относительно просто реализовать другой драйвер или подмену хранилища (для тестов/миграции).

### 15.5. Документация и поддержка API

* API-спецификация должна быть автоматически сгенерирована (Swagger/OpenAPI) и поддерживаться актуальной.
* Типы DTO и структуру запросов/ответов согласовывать между фронтендом и бэкендом (допустима автогенерация из OpenAPI).

### 15.6. Требования по тестированию и покрытию

* Для всех модулей бизнес-логики (слой service) и API реализовать автоматизированные модульные и интеграционные тесты.
* Для фронтенда реализовывать компонентные и e2e-тесты (Jest, Testing Library, Playwright/Cypress).
* Покрытие кода тестами — не ниже 80% для бизнес-логики и критически важных функций UI.
* Все новые функции и правки сопровождаются тестами — тесты пишутся параллельно с кодом.
* Покрытие и прохождение тестов обязательно проверяется на CI перед деплоем/мерджем.
* Проверки в тестах и валидации должны включать:

  * невозможность ввода/сохранения отрицательных балансов и притоков;
  * отсечение лишних знаков (более двух после запятой);
  * корректный расчет доходностей, агрегаций и отображения сумм.

---

## 16. Валютные курсы и конвертация: дополнительные правила

### 16.1. Выбор даты курса

* Для **закрытого месяца**:

  * Используется курс на дату закрытия месяца, либо на последнюю доступную дату перед ней (если курс за день закрытия отсутствует).
* Для **открытого месяца**:

  * Используется курс «последней доступной даты» из ЦБ РФ (последний рабочий день, для которого есть котировка).

### 16.2. Ошибки и отсутствие курса

* Если курс для нужной пары валют/даты не найден:

  * В API агрегатов (`/dashboard`, `/balances`) возвращается:

    * частичная информация по тем счетам, где курс есть;
    * поле `missing_rates` с перечислением валют/дат, по которым расчёт невозможен.
* На UI:

  * Отображается алерт о неполноте данных (например, «Не хватает курсов для корректного пересчёта»).
  * Значения, которые не могут быть корректно посчитаны, помечаются как `—` / `N/A`.

### 16.3. Механизм получения курсов

* Реализовать отдельный сервис `CurrencyRateService`, не вызывающий cbr.ru напрямую из контроллеров.
* Предусмотреть:

  * Фоновую подкачку курсов (scheduler/cron) раз в сутки.
  * Lazy-fetch: при запросе периода без курсов сервис загружает данные, сохраняет в БД и возвращает потребителю.
  * Кеширование курсов в памяти на время обработки запроса.

---

## 17. Дополнительные требования к API

### 17.1. Единый формат ошибок

Формат ошибок API должен быть стандартизирован.

Пример:

```json
{
  "success": false,
  "error_code": "VALIDATION_ERROR",
  "message": "Некорректные данные",
  "details": {
    "field_errors": {
      "amount": "Значение не может быть отрицательным"
    }
  }
}
```

Типовые `error_code`:

* `VALIDATION_ERROR`
* `AUTH_REQUIRED`
* `FORBIDDEN`
* `NOT_FOUND`
* `MONTH_ALREADY_CLOSED`
* `MONTH_CLOSE_INCOMPLETE_DATA`
* `ACCOUNT_HAS_BALANCES`
* `INIT_ALREADY_DONE`
* `CURRENCY_RATE_NOT_FOUND`
* `INTERNAL_ERROR`

### 17.2. Идемпотентность ключевых операций

* `POST /api/months/close`:

  * Повторный вызов для уже закрытого месяца:

    * не меняет состояние;
    * возвращает либо `200` с `error_code: "MONTH_ALREADY_CLOSED"`, либо `409` (решение за проектом, должно быть задокументировано).

* `POST /api/init`:

  * При повторном вызове после успешной инициализации:

    * новый пользователь не создаётся;
    * возвращается `400/409` с `error_code: "INIT_ALREADY_DONE"`.

### 17.3. Ограничения на размеры чисел

* Баланс / net_flow:

  * Диапазон, например, `0.00 … 1_000_000_000.00` (точное значение согласовывается).
* Процентная доходность:

  * Сервер считает без ограничений, но при выходе за разумные пределы допускается логирование как аномалии.

---

## 18. Локализация и форматирование

* Язык интерфейса по умолчанию — русский, но:

  * все форматы дат/чисел централизованы и не зависят от конкретного экрана;
  * логика локализации должна быть вынесена в отдельный модуль/слой.

### 18.1. Формат чисел

* Внутреннее хранение — числовые типы (decimal/number).
* Форматирование на UI:

  * Применяется единый форматтер (например, через Intl).
  * Поддержка различных локалей (например, в будущем `1 234 567,89` vs `1,234,567.89`) через настройки пользователя.

### 18.2. Формат дат

* В API:

  * Использовать ISO-формат: `YYYY-MM-DD` или `YYYY-MM-DDTHH:mm:ssZ`.
* В UI:

  * Локализованное отображение (например, `DD.MM.YYYY`), контролируемое настройками и общим модулем форматирования.

---

## 19. DevOps и окружения

### 19.1. Окружения

Минимальный набор окружений:

* `dev` — разработка, нестабильные версии.
* `stage` — стенд для тестирования и приёмки.
* `prod` — промышленная среда.

Для каждого окружения:

* Отдельная база MongoDB.
* Собственный набор переменных окружения (подключение к БД, URL внешних сервисов, секреты).

### 19.2. Конфигурация и секреты

* Настройки приложения (строки подключения, `JWT_SECRET`, URL сервиса курсов, режим логирования) хранятся в переменных окружения.
* Жёстко прописанные секреты в исходном коде запрещены.

### 19.3. Health-check

* Реализовать endpoint:

  * `GET /api/health`
    Который возвращает:
  * статус сервиса;
  * статус подключения к БД;
  * опционально — статус доступности внешнего сервиса курсов (проверка может выполняться лениво/кэшированно).

---

# Примерные тест-кейсы (Test Cases) для платформы мониторинга инвестиционных счетов

## 1. Балансы и валидация суммы

### 1.1. Ввод положительного значения

* Ввести баланс “12345.67”.
* Ожидание: значение успешно сохраняется, отображается с двумя знаками после запятой.

### 1.2. Ввод значения с тремя знаками после запятой

* Ввести баланс “100.789”.
* Ожидание: система не позволяет сохранить, либо округляет и сообщает пользователю; сохраняется “100.78” или “100.79” (поведение должно быть заранее согласовано и задокументировано).

### 1.3. Ввод отрицательного баланса

* Ввести “-500”.
* Ожидание: появляется ошибка, значение не сохраняется ни на сервере, ни на фронтенде.

### 1.4. Ввод баланса с нечисловым значением

* Ввести “12abc”.
* Ожидание: появляется ошибка, значение не сохраняется.

---

## 2. Нетто-притоки (net_flow)

### 2.1. Ввод положительного и нулевого притока

* Ввести “500” и “0”.
* Ожидание: сохраняется корректно, отображается не более двух знаков после запятой.

### 2.2. Ввод отрицательного притока

* Ввести “-100”.
* Ожидание: в соответствии с финальными бизнес-правилами:

  * либо ошибка валидации (если отрицательные net_flow запрещены),
  * либо корректное сохранение с интерпретацией как отток средств (если выбрана модель со знаком).

---

## 3. Счета

### 3.1. Создание нового счета

* Создать счет с некорректным именем (пустая строка или строка длиннее 128 символов).
* Ожидание: валидация, счет не сохраняется.

### 3.2. Создание счета с существующим именем

* Попытаться создать счет с именем, уже существующим у данного пользователя.
* Ожидание: ошибка валидации (если введено соответствующее бизнес-правило уникальности).

### 3.3. Создание счета без выбора валюты или провайдера

* Ожидание: операция блокируется, фронтенд и бэкенд возвращают ошибку.

### 3.4. Архивация счета

* Архивировать активный счет.
* Ожидание: счет скрывается из списка для ввода остатков, но доступен в списке исторических счетов/в отчётах за прошлые месяцы.

---

## 4. Закрытие месяца

### 4.1. Закрытие месяца с неполными данными по счетам

* Ожидание: система не дает закрыть месяц, сообщает, что данные не заполнены по части счетов (с указанием количества и идентификаторов/имен счетов).

### 4.2. Попытка редактировать баланс в закрытом месяце

* Ожидание: редактирование невозможно:

  * на UI поля недоступны;
  * при прямом запросе к API возвращается ошибка (например, `MONTH_ALREADY_CLOSED`).

---

## 5. Валидация числовых полей

### 5.1. Баланс/нетто-приток больше максимально допустимого числа

* Ввести значение, превышающее установленный лимит (например, `1000000001.00`).
* Ожидание: валидация на клиенте и сервере, ошибка превышения лимита.

---

## 6. API

### 6.1. Проверка ответа `GET /api/balances`

* Ожидание: в ответе присутствуют все необходимые поля:

  * id счета,
  * название,
  * провайдер,
  * валюта,
  * сумма баланса,
  * net_flow,
  * признаки закрытости месяца (если применимо).

### 6.2. Ввод через `POST /api/balances/batch` с частью счетов

* Отправить данные только по части счетов.
* Ожидание:

  * переданные счета обновлены корректно;
  * остальные счета остаются без изменений.

### 6.3. `POST /api/balances/batch` с отрицательными суммами

* Передать отрицательные значения в `amount` или `net_flow` (если по правилам это запрещено).
* Ожидание: ошибка валидации, ни один баланс из батча не сохраняется, возвращается `error_code: "VALIDATION_ERROR"`.

### 6.4. Проверка округления и точности во всех выдачах API

* Ввести значения с большим количеством знаков после запятой.
* Ожидание: API возвращает значения с не более чем двумя знаками после запятой, поведение округления соответствует принятому правилу.

---

## 7. Безопасность

### 7.1. Попытка доступа к счетам другого пользователя

* Выполнить запрос `GET /api/accounts/{id}` или `GET /api/balances` с токеном пользователя А, указав ресурсы пользователя Б.
* Ожидание: отказ в доступе (403 Forbidden или 404 в зависимости от выбранной модели).

### 7.2. Несанкционированный вызов init-метода

* Вызвать `POST /api/init` после инициализации без секретного токена либо при уже непустой базе.
* Ожидание: отказ с `error_code: "INIT_ALREADY_DONE"` или аналогичным.

---

## 8. UI

### 8.1. Поля остаются неактивными при ожидании ответа сервера (спиннер в кнопке)

* Нажать кнопку "Сохранить" на форме балансов.
* Ожидание:

  * кнопка переходит в состояние загрузки (спиннер),
  * поля ввода блокируются до завершения операции,
  * повторное нажатие и изменение данных в момент обработки невозможны.

---

## 9. Тесты на мобильном интерфейсе и адаптив

### 9.1. Ввод баланса с мобильного устройства

* Ввести баланс и net_flow на смартфоне/планшете.
* Ожидание: поведение валидации и форматирования идентично веб-версии, интерфейс корректно адаптируется под экран.

---

## 10. Общий e2e тест-прогон

* Полный сценарий:

  1. Регистрация пользователя.
  2. Вход в систему.
  3. Создание нескольких счетов с разными валютами.
  4. Ввод балансов и нетто-притоков за текущий месяц.
  5. Попытка закрыть месяц с незаполненными данными (ожидаем ошибку).
  6. Дозаполнение данных и успешное закрытие месяца.
  7. Проверка истории по месяцам и работе дашборда.
  8. Проверка невозможности редактирования закрытого месяца.

* Ожидание:

  * все шаги проходят с корректной валидацией;
  * данные в БД согласованы с тем, что отображается в UI;
  * расчеты доходностей и конвертации корректны;
  * ошибки возвращаются в стандартизированном формате.
